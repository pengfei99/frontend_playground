# Introduction of Electron

`Electron` is a framework for building desktop applications using `JavaScript, HTML, and CSS`. By embedding `Chromium and Node.js` into its binary, 
Electron allows you to maintain one JavaScript codebase and create cross-platform apps that work on Windows, macOS, and Linux â€” no native development experience required.

## 1. Lifecycle of an Electron application

When an Electron application launches, it is driven by two `main processes`: 
- the main process
- one or more renderer processes.

### 1.1 Entry point

The entry point of an Electron application is defined in your `package.json`:

```json
"main": "main.js"
```

> By default, it's a javascript file, you can name it as you want. 
> In this tutorial, I called it `main.js`.
> Node.js will run the `main.js` and start the `main process`.

### 1.2 The main process

The main process will execute the code inside `main.js`.

Below is a simple `main.js` sample code with detailed explanation:

```js
// This line imports two core Electron modules from the main process
// app:  Controls your application's event lifecycle (starting, quitting, etc.)
// BrowserWindow: A class that creates and manages application windows
const { app, BrowserWindow } = require('electron/main')

// This line imports path module of Node.js
// The node: prefix explicitly indicates it's a Node.js core module
// This module helps with handling file paths across different operating systems
const path = require('node:path')

// define a function that will create a new application window
function createWindow () {
    // create a new browser window instance
  const win = new BrowserWindow({
    width: 800,
    height: 600,
    // sets webPreferences option for the window
    webPreferences: {
        // Specifies a preload script that will run in the renderer process before web content begins loading
        // __dirname is the directory where the current script(main.js) is located
      preload: path.join(__dirname, 'preload.js')
    }
  })
  // Loads the index.html file into the window
  // This is the main HTML content that will be displayed in your application
  win.loadFile('index.html')
}
// app.whenReady() returns a `Promise` that resolves when Electron has initialized
// .then(() => {...}) executes the callback function once the app is ready
app.whenReady().then(() => {
    // The callback function is the createwinow() function we defined before that simply creates the main application window
  createWindow()

  // Sets up an event listener for the 'activate' event on the app
  // This event is triggered when the user clicks on the app's dock icon (macOS) or taskbar icon
  app.on('activate', () => {
    // The callback checks if there are no open windows (BrowserWindow.getAllWindows().length === 0)
    // If no windows are open, it creates a new one by calling createWindow()
    // This is macOS-specific behavior to match the platform's UX expectations
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow()
    }
  })
})

// Sets up an event listener for when all windows are closed
app.on('window-all-closed', () => {
    // callback function checks if the platform is not macOS ('darwin' is the identifier for macOS)
    // If it's not macOS, the app quits completely with app.quit()
    // On macOS, applications typically continue running even when all windows are closed
   // This behavior aligns with platform-specific UX expectations (apps stay running in the dock on macOS)
  if (process.platform !== 'darwin') {
    app.quit()
  }
})
```

### 1.3 Renderer process 

In the `createWindow()` function of `main.js`. We have two components which defines the behavior of `renderer process`.
- preload.js : in webPreferences
- win.loadFile('index.html')


#### 1.3.1 The preload script

Before render the content of `index.html`, Electron loads the `preload.js` script first. This script runs in a sandboxed context with:
- Access to `Node.js`
- Access to the `browser's window object`